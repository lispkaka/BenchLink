# 测试用例断言功能说明

## 📋 断言判断规则

测试用例是否通过由以下条件决定：

1. **HTTP 状态码**：必须是 2xx（200-299）
2. **所有断言都通过**：包括常规断言和手动断言脚本
3. **没有执行错误**：请求成功发送并接收到响应

## 🔧 支持的断言类型

### 1. **常规断言**（图形化配置）

#### 状态码断言 (status_code)
- 验证响应状态码是否等于期望值
- 配置示例：`expected: 200`

#### 响应时间断言 (response_time)
- 验证响应时间是否小于等于期望值（单位：毫秒）
- 配置示例：`expected: 1000`（期望响应时间 <= 1000ms）

#### 包含文本断言 (contains)
- 验证响应体是否包含指定文本
- 配置示例：`expected: "success"`

#### JSON路径断言 (json_path)
- 通过JSON路径提取值并验证
- 配置示例：
  ```json
  {
    "json_path": "data.user.id",
    "value": "123"
  }
  ```

#### 相等断言 (equals)
- 验证值是否相等
- 配置示例：
  ```json
  {
    "json_path": "code",
    "expected": 0
  }
  ```

### 2. **手动断言**（Python脚本）⭐ 新增

支持使用 Python 脚本编写自定义断言，更灵活强大！

#### 可用变量

- `status_code`: 响应状态码（整数）
- `headers`: 响应头字典
- `body`: 响应体文本（字符串）
- `json`: JSON响应对象（如果响应是JSON格式）
- `time`: 响应时间（毫秒，浮点数）
- `response`: requests.Response 对象（完整响应对象）
- `variables`: 变量字典
- `testcase`: 测试用例对象
- `api`: API对象

#### 断言辅助函数

- `assert_equal(actual, expected, message='')`: 相等断言
- `assert_not_equal(actual, expected, message='')`: 不相等断言
- `assert_contains(container, item, message='')`: 包含断言
- `assert_greater_than(actual, expected, message='')`: 大于断言
- `assert_less_than(actual, expected, message='')`: 小于断言
- `assert_true(condition, message='')`: 真值断言
- `assert_false(condition, message='')`: 假值断言

#### 手动断言脚本示例

**示例1：验证状态码**
```python
assert_equal(status_code, 200, '状态码应为200')
```

**示例2：验证JSON响应**
```python
assert_equal(json['code'], 0, '返回码应为0')
assert_equal(json['data']['user']['name'], 'admin', '用户名应为admin')
```

**示例3：验证响应时间**
```python
assert_less_than(time, 1000, '响应时间应小于1秒')
```

**示例4：验证响应体包含文本**
```python
assert_contains(body, 'success', '响应应包含success')
```

**示例5：复杂验证逻辑**
```python
# 验证返回码为0且数据不为空
assert_equal(json['code'], 0, '返回码应为0')
assert_true(len(json.get('data', [])) > 0, '数据不应为空')

# 验证用户ID是数字且大于0
user_id = json.get('data', {}).get('user_id')
assert_true(isinstance(user_id, int), '用户ID应为整数')
assert_greater_than(user_id, 0, '用户ID应大于0')
```

**示例6：验证响应头**
```python
assert_equal(headers.get('Content-Type'), 'application/json', 'Content-Type应为application/json')
```

**示例7：自定义验证逻辑**
```python
# 验证响应数据结构
if json.get('code') == 0:
    data = json.get('data', {})
    assert_true('token' in data, '响应应包含token')
    assert_true(len(data['token']) > 10, 'token长度应大于10')
else:
    raise AssertionError(f"返回码错误: {json.get('code')}")
```

## 🎯 使用方式

### 前端配置

1. 创建或编辑测试用例
2. 切换到"断言配置"标签页
3. 添加常规断言或手动断言脚本
4. 保存测试用例

### 断言执行顺序

1. 发送HTTP请求
2. 执行常规断言
3. 执行手动断言脚本
4. 合并所有断言结果
5. 判断是否通过（所有断言都通过 + 状态码2xx）

## ✅ 执行结果示例

```json
{
  "success": true,
  "status_code": 200,
  "assertions": [
    {
      "type": "status_code",
      "expected": 200,
      "actual": 200,
      "success": true,
      "message": "状态码断言: 期望 200, 实际 200"
    },
    {
      "type": "manual",
      "description": "验证返回码",
      "success": true,
      "message": "手动断言通过"
    }
  ]
}
```

## 🔒 安全性说明

手动断言脚本在受限环境中执行：
- 禁用了大部分内置函数（`__builtins__` 为空）
- 只能使用提供的变量和断言函数
- 建议：生产环境可以考虑使用更安全的沙箱执行方式

## 💡 最佳实践

1. **优先使用常规断言**：对于简单的验证，使用图形化断言更直观
2. **复杂逻辑用手动断言**：需要复杂验证逻辑时使用Python脚本
3. **清晰的断言描述**：为每个断言添加清晰的描述，方便调试
4. **合理的断言顺序**：先验证基础条件（状态码），再验证业务逻辑
5. **错误信息要详细**：在手动断言中使用有意义的错误消息

## 🚀 未来扩展

- [ ] 支持更多断言类型（正则表达式、类型检查等）
- [ ] 断言模板库（常用断言脚本模板）
- [ ] 断言分组和标签
- [ ] 断言执行性能分析
- [ ] 更安全的脚本执行沙箱

---

**最后更新：2025-10-31**










