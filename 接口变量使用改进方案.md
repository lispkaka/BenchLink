# 接口变量使用改进方案

## 一、当前问题分析

### 1.1 问题表现

**当前接口定义方式：**
- 接口1（GET）：`/posts/${post_id}` - URL中直接包含变量
- 接口2（POST）：Body中包含 `{"userId": "${userId}"}` - Body中直接包含变量

**问题场景：**
当用户单独测试接口时（不通过测试用例），会出现：
- ❌ URL无法正确替换：`/posts/${post_id}` → 发送到服务器的就是字面量 `${post_id}`
- ❌ Body无法正确替换：`{"userId": "${userId}"}` → 服务器收到的就是字面量 `"${userId}"`
- ❌ 接口无法独立运行，必须依赖外部变量

### 1.2 问题根源

**设计问题：**
1. **接口定义与用例变量耦合**：接口定义中直接使用了用例层级的变量
2. **缺少变量默认值机制**：单独测试接口时，没有变量输入界面或默认值
3. **接口可测试性差**：接口定义应该能够独立测试，不依赖外部上下文

---

## 二、参考方案：LunarLink (HttpRunner) 的做法

### 2.1 LunarLink 的核心设计理念

根据 [LunarLink 项目](https://github.com/tahitimoon/LunarLink) 的设计：

1. **接口定义层（API）**：
   - API 是**纯净的接口定义**，对应后端一个 HTTP 接口
   - API 可以**单独运行**（调试功能）
   - API 定义使用**原始值**或**占位符**，不依赖变量

2. **测试用例层（TestCase）**：
   - 用例由多个 API 组成（一个用例 = 多个步骤）
   - 用例层面管理**变量**、**断言**、**前后置脚本**
   - 用例可以**覆盖** API 的 URL、Headers、Body
   - **变量提取**从响应中获取，供后续步骤使用

3. **接口依赖实现**：
   - 通过用例间的**变量传递**实现
   - 用例1提取变量 → 用例2使用变量
   - 在测试套件中按顺序执行，变量在套件级别共享

### 2.2 HttpRunner 的标准做法

HttpRunner 采用三层结构：
```
API定义（template）→ 测试步骤（step）→ 测试用例（testcase）
```

- **API 模板**：定义接口的结构，使用占位符（如 `{user_id}`）
- **测试步骤**：引用 API 模板，提供具体的参数值
- **测试用例**：组合多个步骤，管理变量流转

---

## 三、改进方案对比

### 方案A：接口定义使用原始值 + 用例覆盖（推荐⭐⭐⭐⭐⭐）

**核心思想：** 接口定义保持纯净，用例层负责变量注入

**实现方式：**

1. **接口定义使用原始值或占位符：**
   ```python
   # 接口1：获取文章详情
   URL: /posts/1  # 或者 /posts/{post_id} (占位符，不替换)
   Method: GET
   Body: {}  # 空
   
   # 接口2：创建新文章
   URL: /posts
   Method: POST
   Body: {
       "title": "测试文章标题",
       "body": "这是测试文章的内容",
       "userId": 1  # 使用示例值，不是变量
   }
   ```

2. **测试用例层负责覆盖：**
   ```python
   # 测试用例1：步骤1 - 获取文章详情
   API: 引用"获取文章详情"接口
   覆盖参数:
     - URL: /posts/${post_id}  # 用例层面覆盖URL
     或
     - Path参数: {"post_id": 1}  # 使用路径参数替换
   变量提取:
     - userId: $.userId
     - postId: $.id
   
   # 测试用例2：步骤2 - 创建新文章
   API: 引用"创建新文章"接口
   覆盖参数:
     - Body覆盖: {"userId": "${userId}"}  # 用例层面覆盖Body
   变量提取:
     - new_post_id: $.id
   ```

3. **单独测试接口时的处理：**
   - 接口可以独立运行，使用接口定义中的原始值
   - 提供"调试模式"，允许用户临时覆盖 URL/Headers/Body
   - 不需要变量也能正常测试

**优点：**
- ✅ 接口定义独立，可以单独测试
- ✅ 符合 HttpRunner/LunarLink 的设计理念
- ✅ 接口复用性强，不同用例可以有不同的参数
- ✅ 职责清晰：接口定义结构，用例管理变量

**缺点：**
- ⚠️ 需要在 TestCase 模型中增加字段（URL覆盖、Body覆盖等）
- ⚠️ 需要修改执行器逻辑，支持用例级别的参数覆盖

---

### 方案B：接口定义支持默认值 + 变量输入界面（改进当前方案⭐⭐⭐）

**核心思想：** 保持当前设计，但在接口定义时提供默认值，单独测试时允许输入变量

**实现方式：**

1. **接口定义支持默认值：**
   ```python
   # 接口1：获取文章详情
   URL: /posts/${post_id}
   变量默认值: {"post_id": 1}
   
   # 接口2：创建新文章
   URL: /posts
   Body: {"userId": "${userId}"}
   变量默认值: {"userId": 1}
   ```

2. **单独测试接口时：**
   - 自动使用默认值替换变量
   - 提供变量输入界面，允许用户覆盖默认值
   - 如果变量未定义且无默认值，提示用户输入

3. **在测试用例中：**
   - 用例的变量会覆盖接口默认值
   - 行为与当前一致

**优点：**
- ✅ 改动最小，只需要增加默认值字段
- ✅ 向后兼容，现有接口可以逐步添加默认值
- ✅ 接口可以独立测试（使用默认值）

**缺点：**
- ⚠️ 接口定义仍然包含变量占位符，不够纯净
- ⚠️ 需要维护两套变量：接口默认值 + 用例变量
- ⚠️ 不符合 HttpRunner 的设计理念

---

### 方案C：接口定义使用占位符 + 执行时强制提供变量（当前方案改进⭐⭐）

**核心思想：** 保持当前设计，但在单独测试接口时强制要求提供变量

**实现方式：**

1. **接口定义保持不变：**
   ```python
   URL: /posts/${post_id}
   Body: {"userId": "${userId}"}
   ```

2. **单独测试接口时：**
   - 分析接口定义中需要的变量（解析 `${variable}`）
   - 要求用户必须提供所有变量才能执行
   - 提供变量输入界面
   - 如果变量缺失，提示错误并列出缺失的变量

3. **在测试用例中：**
   - 行为与当前一致，用例提供变量

**优点：**
- ✅ 改动最小，只需要增加变量检查逻辑
- ✅ 明确告知用户需要提供哪些变量

**缺点：**
- ❌ 接口无法独立运行，必须提供变量
- ❌ 用户体验差，每次测试都要输入变量
- ❌ 接口定义仍然与变量耦合

---

### 方案D：混合方案 - 接口模板 + 用例实例化（最优但复杂⭐⭐⭐⭐）

**核心思想：** 类似 HttpRunner，分离接口模板和用例参数

**实现方式：**

1. **API 模型改造：**
   ```python
   # 新增字段
   is_template: Boolean  # 是否为模板
   template_variables: JSON  # 模板变量定义（如 {"post_id": "integer"}）
   default_values: JSON  # 默认值
   ```

2. **接口定义使用模板语法：**
   ```python
   # 接口1：获取文章详情（模板）
   URL: /posts/{post_id}
   is_template: True
   template_variables: {"post_id": "integer"}
   default_values: {"post_id": 1}
   
   # 接口2：创建新文章（模板）
   URL: /posts
   Body: {
       "title": "{title}",
       "body": "{body}",
       "userId": "{userId}"
   }
   is_template: True
   template_variables: {
       "title": "string",
       "body": "string", 
       "userId": "integer"
   }
   default_values: {
       "title": "测试文章标题",
       "body": "这是测试文章的内容",
       "userId": 1
   }
   ```

3. **测试用例实例化模板：**
   ```python
   # 测试用例1
   API: 引用"获取文章详情"模板
   实例化参数: {"post_id": 1}  # 或使用变量 {"post_id": "${env_post_id}"}
   
   # 测试用例2
   API: 引用"创建新文章"模板
   实例化参数: {
       "title": "新文章",
       "body": "内容",
       "userId": "${userId}"  # 使用步骤1提取的变量
   }
   ```

4. **单独测试接口时：**
   - 如果是模板，使用默认值实例化
   - 允许用户覆盖默认值

**优点：**
- ✅ 最灵活，接口可以定义参数类型和约束
- ✅ 接口定义清晰，知道需要哪些参数
- ✅ 支持接口复用和参数化测试
- ✅ 最接近 HttpRunner 的设计

**缺点：**
- ❌ 改动较大，需要重构 API 模型和执行器
- ❌ 学习成本较高
- ❌ 实现复杂度高

---

## 四、推荐方案对比

| 方案 | 改动成本 | 用户体验 | 接口独立性 | 符合标准 | 推荐度 |
|------|---------|---------|-----------|---------|--------|
| **方案A** | 中 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 方案B | 低 | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ |
| 方案C | 极低 | ⭐⭐ | ⭐⭐ | ⭐ | ⭐⭐ |
| 方案D | 高 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |

---

## 五、最终推荐：方案A（接口定义使用原始值 + 用例覆盖）

### 5.1 为什么推荐方案A？

1. **符合行业标准**：与 HttpRunner/LunarLink 的设计理念一致
2. **职责清晰**：
   - **接口定义**：描述接口的结构和示例
   - **测试用例**：管理变量、参数覆盖、断言
   - **测试套件**：组合用例，管理变量流转
3. **接口可独立测试**：接口定义使用原始值，可以独立运行
4. **灵活性高**：同一个接口可以被多个用例使用，每个用例可以有不同的参数
5. **改动适中**：不需要重构整个模型，只需要：
   - API 定义改为使用原始值
   - TestCase 增加覆盖字段（url_override, body_override 等）
   - 执行器支持用例级别的参数覆盖

### 5.2 方案A的实现细节

#### 5.2.1 数据模型改造

**TestCase 模型新增字段：**
```python
class TestCase(models.Model):
    # ... 现有字段 ...
    
    # 新增：用例级别的参数覆盖
    url_override = models.CharField(max_length=500, blank=True, null=True, 
                                    verbose_name='URL覆盖（支持变量）')
    headers_override = models.JSONField(default=dict, 
                                        verbose_name='请求头覆盖（支持变量）')
    body_override = models.JSONField(default=dict, 
                                     verbose_name='请求体覆盖（支持变量）')
    params_override = models.JSONField(default=dict, 
                                       verbose_name='查询参数覆盖（支持变量）')
    
    # 或者使用一个统一的覆盖字段（更灵活）
    request_override = models.JSONField(default=dict,
                                        verbose_name='请求覆盖配置', 
                                        help_text='{"url": "/posts/${post_id}", "body": {...}}')
```

#### 5.2.2 执行器逻辑改造

**TestCaseExecutor 执行逻辑：**
```python
def _build_url(self) -> str:
    """构建完整的请求URL"""
    # 优先级：用例覆盖 > 接口定义
    if self.testcase.url_override:
        api_url = self.testcase.url_override
    else:
        api_url = self.api.url
    
    # 替换变量
    api_url = self._replace_variables(api_url)
    
    # 拼接base_url
    if self.environment and self.environment.base_url:
        base_url = self.environment.base_url.rstrip('/')
        api_url = api_url.lstrip('/')
        return f"{base_url}/{api_url}"
    
    return api_url

def _build_body(self) -> Dict:
    """构建请求体"""
    # 优先级：用例覆盖 > 接口定义
    if self.testcase.body_override:
        body = self.testcase.body_override
    else:
        body = self.api.body or {}
    
    # 替换变量
    return self._replace_variables_in_dict(body)
```

#### 5.2.3 接口定义示例（改造后）

```python
# 接口1：获取文章详情
name: "获取文章详情"
method: "GET"
url: "/posts/1"  # 使用原始值，作为示例
description: "获取指定ID的文章详情，返回文章信息"
body: {}

# 接口2：创建新文章
name: "创建新文章"
method: "POST"
url: "/posts"
body: {
    "title": "测试文章标题",
    "body": "这是测试文章的内容",
    "userId": 1  # 使用示例值
}
```

#### 5.2.4 测试用例定义示例（改造后）

```python
# 测试用例1：步骤1 - 获取文章详情
name: "步骤1：获取文章详情"
api: 引用"获取文章详情"接口
url_override: "/posts/${post_id}"  # 用例层面覆盖，使用变量
# 或使用 request_override: {"url": "/posts/${post_id}"}
variables: {
    "post_id": 1,  # 初始值
    "extractors": {
        "userId": "$.userId",
        "postId": "$.id"
    }
}
assertions: [...]

# 测试用例2：步骤2 - 创建新文章
name: "步骤2：创建新文章（使用步骤1的userId）"
api: 引用"创建新文章"接口
body_override: {  # 用例层面覆盖，使用变量
    "title": "测试文章标题",
    "body": "这是测试文章的内容",
    "userId": "${userId}"  # 使用步骤1提取的变量
}
variables: {
    "extractors": {
        "new_post_id": "$.id"
    }
}
assertions: [...]
```

#### 5.2.5 单独测试接口的行为

- 使用接口定义中的原始值（`/posts/1`，`{"userId": 1}`）
- 提供"调试模式"，允许用户临时修改 URL/Headers/Body
- 不需要变量也能正常测试

#### 5.2.6 参数化功能支持（单个接口参数化）

**方案A完全支持参数化功能！** 这是方案A的一个重要优势。

##### 方案A的参数化实现方式

**1. API 模型新增参数化字段：**
```python
class API(models.Model):
    # ... 现有字段 ...
    
    # 新增：参数化数据（用于单个接口的批量测试）
    parameterized_data = models.JSONField(
        default=list,
        verbose_name='参数化数据',
        help_text='[{"post_id": 1}, {"post_id": 2}, {"post_id": 3}]'
    )
    
    # 新增：参数化模式
    parameterized_mode = models.CharField(
        max_length=20,
        choices=[
            ('disabled', '禁用'),
            ('enabled', '启用'),
        ],
        default='disabled',
        verbose_name='参数化模式'
    )
```

**2. 单独测试接口时的参数化流程：**

```python
# API 定义
name: "获取文章详情"
method: "GET"
url: "/posts/1"  # 原始值
parameterized_mode: "enabled"
parameterized_data: [
    {"post_id": 1},
    {"post_id": 2},
    {"post_id": 3}
]

# 执行逻辑（APIViewSet.execute）：
def execute(self, request, pk=None):
    api_instance = self.get_object()
    
    # 检查是否启用参数化
    if api_instance.parameterized_mode == 'enabled' and api_instance.parameterized_data:
        results = []
        for param_set in api_instance.parameterized_data:
            # 使用参数集构建请求
            variables = param_set  # 例如: {"post_id": 1}
            url = self._replace_variables(api_instance.url, variables)
            body = self._replace_variables_in_dict(api_instance.body, variables)
            # ... 发送请求并收集结果
            results.append(result)
        return Response({'parameterized': True, 'results': results})
    else:
        # 普通执行（单次）
        # ... 使用原始值执行
```

**3. 参数化数据来源（三种方式）：**

**方式1：API 自身定义参数化数据**
```python
# API 模型中的 parameterized_data 字段
parameterized_data: [
    {"post_id": 1, "title": "文章1"},
    {"post_id": 2, "title": "文章2"},
    {"post_id": 3, "title": "文章3"}
]
```

**方式2：使用环境配置的参数化数据**
```python
# Environment 模型中的 parameterized_data 字段
environment.parameterized_data: [
    {"user_id": "1", "post_id": "1"},
    {"user_id": "1", "post_id": "2"},
]

# 单独测试接口时，如果API未定义参数化，可以使用环境的参数化数据
```

**方式3：临时指定参数化数据（前端传入）**
```python
# 前端调用时传入
POST /api/apis/{id}/execute/
{
    "parameterized_data": [
        {"post_id": 1},
        {"post_id": 2}
    ]
}
```

##### 参数化执行示例

**场景：测试获取不同ID的文章**

```python
# API 定义
{
    "name": "获取文章详情",
    "method": "GET",
    "url": "/posts/${post_id}",  # 使用变量占位符（但URL覆盖在用例层）
    # 或者更好的方式：
    "url": "/posts/{post_id}",   # 使用占位符语法
    "parameterized_mode": "enabled",
    "parameterized_data": [
        {"post_id": 1},
        {"post_id": 2},
        {"post_id": 3}
    ]
}

# 执行时：
# 第1次：GET /posts/1
# 第2次：GET /posts/2
# 第3次：GET /posts/3
# 返回3个结果
```

##### 测试用例层面的参数化

**TestCase 模型同样支持参数化：**
```python
class TestCase(models.Model):
    # ... 现有字段 ...
    
    # 参数化数据（用于用例批量执行）
    parameterized_data = models.JSONField(
        default=list,
        verbose_name='参数化数据'
    )
    parameterized_mode = models.CharField(...)

# 用例执行时：
# 如果启用参数化，用例会执行多次，每次使用不同的参数集
# 每次执行都可以提取不同的变量，供后续步骤使用
```

##### 方案A参数化优势

✅ **接口层面参数化**：单个接口可以独立进行参数化测试
✅ **用例层面参数化**：测试用例也可以进行参数化测试
✅ **环境层面参数化**：环境配置支持全局参数化数据
✅ **灵活组合**：可以同时使用API参数化 + 环境参数化
✅ **变量替换**：参数化数据中的变量可以正确替换到 URL/Body
✅ **结果统计**：参数化执行后，可以统计通过/失败数量

##### 与 HttpRunner 的参数化对比

**HttpRunner 的参数化方式：**
```yaml
# HttpRunner 使用 parameters 字段
teststeps:
  - name: 获取文章
    request:
      url: /posts/$post_id
    parameters:
      post_id: [1, 2, 3]  # 或 [{"post_id": 1}, {"post_id": 2}]
```

**方案A的参数化方式（兼容HttpRunner思想）：**
```python
# API 定义
{
    "url": "/posts/${post_id}",  # 或支持 {post_id} 语法
    "parameterized_data": [
        {"post_id": 1},
        {"post_id": 2},
        {"post_id": 3}
    ]
}
```

**结论：方案A完全支持参数化，且实现方式与HttpRunner一致！**

---

## 六、迁移方案

如果采用方案A，现有数据的迁移：

1. **迁移脚本：**
   ```python
   # 对于包含变量的接口定义，提取变量到用例的覆盖字段
   # 例如：API.url = "/posts/${post_id}" 
   #      → API.url = "/posts/1" (改为原始值)
   #      → TestCase.url_override = "/posts/${post_id}" (用例覆盖)
   ```

2. **兼容性处理：**
   - 执行器优先检查用例覆盖字段
   - 如果没有覆盖字段，使用接口定义（向后兼容）

---

## 七、总结

**当前问题：**
- 接口定义中直接使用变量，导致单独测试接口时失败

**推荐解决方案：**
- **方案A**：接口定义使用原始值，测试用例负责变量覆盖
- 符合 HttpRunner/LunarLink 的设计理念
- 接口可独立测试，职责清晰，灵活性高

**参数化支持：**
- ✅ **方案A完全支持参数化功能**
- 支持API层面参数化（单个接口批量测试）
- 支持用例层面参数化（用例批量执行）
- 支持环境层面参数化（全局参数化数据）
- 实现方式与HttpRunner/LunarLink一致

**实施建议：**
1. 短期：可以先实现方案B（添加默认值），快速解决单独测试问题
2. 中期：逐步迁移到方案A（接口定义原始值 + 用例覆盖），重构代码
   - 实施时同时加入参数化功能支持
3. 长期：考虑方案D（模板系统），如果业务需要更复杂的参数化

